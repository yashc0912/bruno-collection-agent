/**
 * AI-Powered API Test Generator
 * 
 * Just provide:
 * 1. URL
 * 2. Payload
 * 3. Expected outcome
 * 
 * AI generates complete test suite automatically!
 */

const fs = require('fs');
const path = require('path');

class AITestGenerator {
  constructor() {
    this.testSuiteDir = './tests/generated';
    this.ensureDirectoryExists(this.testSuiteDir);
  }

  ensureDirectoryExists(dir) {
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
  }

  /**
   * Generate a complete test from minimal inputs
   * @param {Object} config - Test configuration
   * @param {string} config.name - Test name
   * @param {string} config.url - API endpoint
   * @param {string} config.method - HTTP method (GET, POST, etc.)
   * @param {Object} config.payload - Request body
   * @param {Object} config.headers - Request headers
   * @param {Object} config.auth - Authentication config
   * @param {Array} config.assertions - Expected outcomes
   */
  generateTest(config) {
    const {
      name,
      url,
      method = 'POST',
      payload = {},
      headers = {},
      auth = null,
      assertions = []
    } = config;

    // Generate test variations automatically
    const tests = [
      this.generatePositiveTest(config),
      this.generateNegativeTests(config),
      this.generateEdgeCases(config)
    ];

    // Create test file
    const testContent = this.buildPlaywrightTest(name, tests);
    const fileName = `${this.sanitizeFileName(name)}.spec.js`;
    const filePath = path.join(this.testSuiteDir, fileName);

    fs.writeFileSync(filePath, testContent);
    console.log(`‚úÖ Generated test: ${filePath}`);

    // Generate Bruno file
    this.generateBrunoFile(config);

    return {
      playwrightTest: filePath,
      brunoFile: path.join(this.testSuiteDir, `${this.sanitizeFileName(name)}.bru`)
    };
  }

  generatePositiveTest(config) {
    return {
      type: 'positive',
      name: `${config.name} - Success Scenario`,
      url: config.url,
      method: config.method,
      payload: config.payload,
      headers: config.headers,
      auth: config.auth,
      assertions: [
        { type: 'status', value: 200, operator: 'toBe' },
        { type: 'responseTime', value: 5000, operator: 'toBeLessThan' },
        ...config.assertions
      ]
    };
  }

  generateNegativeTests(config) {
    const negativeTests = [];

    // Invalid payload test
    negativeTests.push({
      type: 'negative',
      name: `${config.name} - Invalid Payload`,
      url: config.url,
      method: config.method,
      payload: this.corruptPayload(config.payload),
      headers: config.headers,
      auth: config.auth,
      assertions: [
        { type: 'status', value: 400, operator: 'toBe' }
      ]
    });

    // Missing auth test (if auth is configured)
    if (config.auth) {
      negativeTests.push({
        type: 'negative',
        name: `${config.name} - Unauthorized`,
        url: config.url,
        method: config.method,
        payload: config.payload,
        headers: config.headers,
        auth: null,
        assertions: [
          { type: 'status', value: 401, operator: 'toBe' }
        ]
      });
    }

    return negativeTests;
  }

  generateEdgeCases(config) {
    return [
      {
        type: 'edge',
        name: `${config.name} - Empty Payload`,
        url: config.url,
        method: config.method,
        payload: {},
        headers: config.headers,
        auth: config.auth,
        assertions: [
          { type: 'status', value: [400, 422], operator: 'toBeOneOf' }
        ]
      }
    ];
  }

  corruptPayload(payload) {
    const corrupted = { ...payload };
    const keys = Object.keys(corrupted);
    if (keys.length > 0) {
      // Remove a required field
      delete corrupted[keys[0]];
    }
    return corrupted;
  }

  buildPlaywrightTest(name, tests) {
    const flatTests = tests.flat();
    
    let testContent = `// Auto-generated by AI Test Generator
// Test Suite: ${name}
// Generated: ${new Date().toISOString()}

import { test, expect } from '@playwright/test';

test.describe('${name}', () => {
`;

    flatTests.forEach(testCase => {
      testContent += this.buildSingleTest(testCase);
    });

    testContent += '});\n';
    return testContent;
  }

  buildSingleTest(testCase) {
    const authHeader = this.buildAuthHeader(testCase.auth);
    const headersCode = JSON.stringify({ ...testCase.headers, ...authHeader }, null, 4);
    const payloadCode = JSON.stringify(testCase.payload, null, 4);

    let assertionsCode = '';
    testCase.assertions.forEach(assertion => {
      if (assertion.type === 'status') {
        assertionsCode += `    expect(response.status()).${assertion.operator}(${assertion.value});\n`;
      } else if (assertion.type === 'responseTime') {
        assertionsCode += `    expect(responseTime).${assertion.operator}(${assertion.value});\n`;
      } else if (assertion.type === 'body') {
        assertionsCode += `    const body = await response.json();\n`;
        assertionsCode += `    expect(body.${assertion.field}).${assertion.operator}(${JSON.stringify(assertion.value)});\n`;
      }
    });

    return `
  test('${testCase.name}', async ({ request }) => {
    const startTime = Date.now();
    
    const response = await request.${testCase.method.toLowerCase()}('${testCase.url}', {
      data: ${payloadCode},
      headers: ${headersCode}
    });
    
    const responseTime = Date.now() - startTime;
    
    console.log('Status:', response.status());
    console.log('Response Time:', responseTime + 'ms');
    
${assertionsCode}
  });
`;
  }

  buildAuthHeader(auth) {
    if (!auth) return {};
    
    if (auth.type === 'basic') {
      const encoded = Buffer.from(`${auth.username}:${auth.password}`).toString('base64');
      return { 'Authorization': `Basic ${encoded}` };
    } else if (auth.type === 'bearer') {
      return { 'Authorization': `Bearer ${auth.token}` };
    } else if (auth.type === 'apikey') {
      return { [auth.headerName || 'X-API-Key']: auth.key };
    }
    
    return {};
  }

  generateBrunoFile(config) {
    const brunoContent = `meta {
  name: ${config.name}
  type: http
  seq: 1
}

${config.method.toLowerCase()} {
  url: ${config.url}
  body: json
  auth: ${config.auth ? config.auth.type : 'none'}
}

${config.auth && config.auth.type === 'basic' ? `auth:basic {
  username: ${config.auth.username}
  password: ${config.auth.password}
}` : ''}

${config.auth && config.auth.type === 'bearer' ? `auth:bearer {
  token: ${config.auth.token}
}` : ''}

headers {
  Content-Type: application/json
${Object.entries(config.headers || {}).map(([key, value]) => `  ${key}: ${value}`).join('\n')}
}

body:json {
${JSON.stringify(config.payload, null, 2).split('\n').map(line => '  ' + line).join('\n')}
}

assert {
  res.status: eq 200
  res.body: isDefined
}

script:post-response {
  console.log("Response:", res.body);
  
  if (res.status === 200) {
    console.log("‚úÖ Test Passed");
  } else {
    console.log("‚ùå Test Failed");
  }
}
`;

    const fileName = `${this.sanitizeFileName(config.name)}.bru`;
    const filePath = path.join(this.testSuiteDir, fileName);
    fs.writeFileSync(filePath, brunoContent);
    console.log(`‚úÖ Generated Bruno file: ${filePath}`);
  }

  sanitizeFileName(name) {
    return name
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-|-$/g, '');
  }

  /**
   * Generate dynamic data helpers
   */
  generateDynamicPayload(payload) {
    const dynamicPayload = { ...payload };
    
    Object.keys(dynamicPayload).forEach(key => {
      const value = dynamicPayload[key];
      
      // Convert to dynamic values
      if (typeof value === 'string') {
        if (value.includes('ID') || value.includes('id')) {
          dynamicPayload[key] = '{{$randomUUID}}';
        } else if (value.includes('name') || value.includes('Name')) {
          dynamicPayload[key] = '{{$randomFullName}}';
        } else if (value.includes('email') || value.includes('Email')) {
          dynamicPayload[key] = '{{$randomEmail}}';
        } else if (value.includes('date') || value.includes('Date')) {
          dynamicPayload[key] = '{{$isoTimestamp}}';
        }
      }
    });
    
    return dynamicPayload;
  }

  /**
   * Generate complete test suite from API collection
   */
  generateTestSuite(apiCollection) {
    console.log('ü§ñ AI Test Generator - Starting...\n');
    
    const results = [];
    
    apiCollection.forEach(api => {
      console.log(`Generating tests for: ${api.name}`);
      const result = this.generateTest(api);
      results.push(result);
    });
    
    console.log(`\n‚úÖ Generated ${results.length} test suites`);
    console.log(`üìÅ Location: ${this.testSuiteDir}`);
    
    return results;
  }
}

// Export for use
module.exports = AITestGenerator;

// Example usage
if (require.main === module) {
  const generator = new AITestGenerator();
  
  // Example: Generate test from minimal inputs
  const exampleAPI = {
    name: 'Create Contract API',
    url: 'https://api.example.com/v1/createContract',
    method: 'POST',
    payload: {
      contractId: '12345',
      customerName: 'Yash',
      status: 'ACTIVE'
    },
    headers: {
      'Content-Type': 'application/json'
    },
    auth: {
      type: 'basic',
      username: 'testuser',
      password: 'testpass'
    },
    assertions: [
      { type: 'body', field: 'status', value: 'ACTIVE', operator: 'toBe' }
    ]
  };
  
  generator.generateTest(exampleAPI);
  console.log('\n‚úÖ Example test generated successfully!');
  console.log('Run it with: npx playwright test tests/generated');
}
